#!/usr/bin/env node
/**
 * SwissKnife Mock Creator
 * 
 * This script generates mock implementations for commonly used modules
 * to help tests pass successfully.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const MOCK_DIR = path.join(process.cwd(), 'test/mocks');
const SRC_DIR = path.join(process.cwd(), 'src');
const AUTO_MOCK_MODULES = [
  'utils/logging/manager',
  'utils/config',
  'utils/prompts',
  'utils/shell',
  'utils/fs',
  'models/project',
  'services/mcp/client',
  'services/mcp/conversation'
];

console.log('SwissKnife Mock Creator');
console.log('='.repeat(50));

// Ensure mock directories exist
function ensureDirExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`Created directory: ${dirPath}`);
  }
}

// Create a base mock directory
ensureDirExists(MOCK_DIR);

// Function to create a mock implementation for a module
function createMockForModule(modulePath) {
  const fullPath = path.join(SRC_DIR, `${modulePath}.js`);
  const mockDir = path.join(MOCK_DIR, path.dirname(modulePath));
  const mockPath = path.join(MOCK_DIR, `${modulePath}.js`);
  
  console.log(`\nCreating mock for: ${modulePath}`);
  
  // Ensure the mock directory exists
  ensureDirExists(mockDir);
  
  // Skip if mock already exists
  if (fs.existsSync(mockPath)) {
    console.log(`Mock already exists at: ${mockPath}`);
    return;
  }
  
  try {
    // Check if the source module exists
    if (!fs.existsSync(fullPath)) {
      console.log(`WARNING: Source module not found: ${fullPath}`);
      // Create a basic generic mock
      createGenericMock(modulePath, mockPath);
      return;
    }
    
    // Read the source file to analyze it
    const content = fs.readFileSync(fullPath, 'utf8');
    
    // Choose the appropriate mock type based on the file content
    if (content.includes('class ')) {
      createClassMock(modulePath, content, mockPath);
    } else if (content.includes('export function') || content.includes('module.exports = function')) {
      createFunctionMock(modulePath, content, mockPath);
    } else {
      createObjectMock(modulePath, content, mockPath);
    }
    
    console.log(`✓ Mock created: ${mockPath}`);
  } catch (error) {
    console.error(`Error creating mock for ${modulePath}:`, error.message);
    // Fallback to generic mock on error
    createGenericMock(modulePath, mockPath);
  }
}

// Create a basic generic mock for when we can't analyze the source
function createGenericMock(modulePath, mockPath) {
  const moduleName = path.basename(modulePath);
  const mockContent = `/**
 * Generic mock for ${modulePath}
 * Auto-generated by SwissKnife Mock Creator
 */

const { jest } = require('@jest/globals');

// Create a basic mock implementation
const mock = {
  // Basic function mocks
  someFunction: jest.fn(),
  execute: jest.fn(),
  run: jest.fn(),
  init: jest.fn(),
  
  // Common properties
  name: '${moduleName}',
  enabled: true,
  config: {}
};

// Add class-like behavior
mock.getInstance = jest.fn().mockReturnValue(mock);

// Export as both default and named export for compatibility
mock.default = mock;
module.exports = mock;
`;

  fs.writeFileSync(mockPath, mockContent, 'utf8');
  console.log(`✓ Created generic mock for ${modulePath}`);
}

// Create a mock for a class-based module
function createClassMock(modulePath, content, mockPath) {
  // Extract class name(s)
  const classMatches = content.match(/class\s+(\w+)/g) || [];
  const classNames = classMatches.map(m => m.replace('class ', '').trim());
  
  if (classNames.length === 0) {
    createGenericMock(modulePath, mockPath);
    return;
  }
  
  // Extract method names
  const methodMatches = content.match(/(?:async\s+)?(?:static\s+)?(\w+)\s*\([^)]*\)\s*{/g) || [];
  const methodNames = methodMatches.map(m => {
    return m.replace(/(?:async\s+)?(?:static\s+)?/, '')
            .replace(/\s*\([^)]*\)\s*{/, '')
            .trim();
  }).filter(m => !['constructor', 'if', 'for', 'while', 'switch', 'catch'].includes(m));
  
  // Create the mock content
  let mockContent = `/**
 * Class mock for ${modulePath}
 * Auto-generated by SwissKnife Mock Creator
 */

const { jest } = require('@jest/globals');

`;

  // Generate mock for each class
  classNames.forEach(className => {
    mockContent += `// Mock implementation for ${className}
class ${className} {
  constructor() {
    // Constructor mock implementation
  }
  
`;

    // Add methods
    methodNames.forEach(method => {
      mockContent += `  ${method}(...args) {
    return jest.fn()();
  }
  
`;
    });

    mockContent += `}

// Add jest mock functions to all methods
${methodNames.map(m => `${className}.prototype.${m} = jest.fn(${className}.prototype.${m});`).join('\n')}

// Add static methods and getInstance pattern
${className}.getInstance = jest.fn().mockReturnValue(new ${className}());

`;
  });

  // Add exports
  mockContent += `// Export the primary class
module.exports = ${classNames[0]};
`;

  if (classNames.length > 1) {
    mockContent += `
// Export additional classes
${classNames.slice(1).map(c => `module.exports.${c} = ${c};`).join('\n')}
`;
  }

  // Add default export for ESM compatibility
  mockContent += `
// Add default export for ESM compatibility
module.exports.default = module.exports;
`;

  fs.writeFileSync(mockPath, mockContent, 'utf8');
  console.log(`✓ Created class mock with ${methodNames.length} methods`);
}

// Create a mock for a function-based module
function createFunctionMock(modulePath, content, mockPath) {
  // Extract the main function name if possible
  const fnMatch = content.match(/(?:export\s+)?(?:function|const|let|var)\s+(\w+)/) || 
                  content.match(/module\.exports\s*=\s*function\s+(\w+)/);
  const fnName = fnMatch ? fnMatch[1] : path.basename(modulePath);
  
  const mockContent = `/**
 * Function mock for ${modulePath}
 * Auto-generated by SwissKnife Mock Creator
 */

const { jest } = require('@jest/globals');

// Create function mock
const ${fnName} = jest.fn().mockImplementation((...args) => {
  // Default implementation returns a resolved promise with empty object
  return Promise.resolve({});
});

// Add utility methods often used in tests
${fnName}.mockResolvedValue = (value) => ${fnName}.mockImplementation(() => Promise.resolve(value));
${fnName}.mockRejectedValue = (error) => ${fnName}.mockImplementation(() => Promise.reject(error));

// Export as both named and default for compatibility
module.exports = ${fnName};
module.exports.default = ${fnName};
`;

  fs.writeFileSync(mockPath, mockContent, 'utf8');
  console.log(`✓ Created function mock for ${fnName}`);
}

// Create a mock for an object module
function createObjectMock(modulePath, content, mockPath) {
  // Try to extract exported properties
  const exportedProps = [];
  
  // Check for ESM exports
  const esmExports = content.match(/export\s+(?:const|let|var|function|class)\s+(\w+)/g) || [];
  esmExports.forEach(exp => {
    const match = exp.match(/export\s+(?:const|let|var|function|class)\s+(\w+)/);
    if (match && match[1]) exportedProps.push(match[1]);
  });
  
  // Check for CommonJS exports
  const cjsExports = content.match(/(?:module\.)?exports\.(\w+)\s*=/g) || [];
  cjsExports.forEach(exp => {
    const match = exp.match(/(?:module\.)?exports\.(\w+)\s*=/);
    if (match && match[1]) exportedProps.push(match[1]);
  });
  
  // Also look for functions that might be exported
  const functions = content.match(/(?:async\s+)?function\s+(\w+)/g) || [];
  functions.forEach(fn => {
    const match = fn.match(/(?:async\s+)?function\s+(\w+)/);
    if (match && match[1] && !exportedProps.includes(match[1])) {
      exportedProps.push(match[1]);
    }
  });
  
  // Create mock content
  let mockContent = `/**
 * Object mock for ${modulePath}
 * Auto-generated by SwissKnife Mock Creator
 */

const { jest } = require('@jest/globals');

// Create object mock
const mock = {
`;

  // Add exported properties as mocks
  if (exportedProps.length > 0) {
    exportedProps.forEach(prop => {
      mockContent += `  ${prop}: jest.fn().mockImplementation(() => {}),
`;
    });
  } else {
    mockContent += `  // Basic function mocks
  execute: jest.fn().mockImplementation(() => Promise.resolve({})),
  run: jest.fn().mockImplementation(() => Promise.resolve({})),
  init: jest.fn().mockImplementation(() => Promise.resolve({})),
  
  // Common properties
  name: '${path.basename(modulePath)}',
  enabled: true,
  config: {}
`;
  }

  mockContent += `};

// Export the mock object
module.exports = mock;
module.exports.default = mock;
`;

  fs.writeFileSync(mockPath, mockContent, 'utf8');
  console.log(`✓ Created object mock with ${exportedProps.length || 'generic'} ${exportedProps.length ? 'properties' : 'structure'}`);
}

// Process all configured modules
console.log('Creating mocks for configured modules...');
AUTO_MOCK_MODULES.forEach(createMockForModule);

console.log('\nMock creation complete!');
console.log(`Created mocks in: ${MOCK_DIR}`);
console.log('\nTo use these mocks in tests:');
console.log(`jest.mock('../../src/path/to/module', () => require('../../test/mocks/path/to/module'));`);
