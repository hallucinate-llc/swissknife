"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkswissknife_web"] = self["webpackChunkswissknife_web"] || []).push([["src_ai_service_ts"],{

/***/ "../node_modules/uuid/dist/esm-browser/native.js":
/*!*******************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/native.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ randomUUID });\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "../node_modules/uuid/dist/esm-browser/regex.js":
/*!******************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/regex.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "../node_modules/uuid/dist/esm-browser/rng.js":
/*!****************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/rng.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "../node_modules/uuid/dist/esm-browser/stringify.js":
/*!**********************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/stringify.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../node_modules/uuid/dist/esm-browser/validate.js\");\n\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "../node_modules/uuid/dist/esm-browser/v4.js":
/*!***************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/v4.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"../node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"../node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"../node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0,_rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "../node_modules/uuid/dist/esm-browser/validate.js":
/*!*********************************************************!*\
  !*** ../node_modules/uuid/dist/esm-browser/validate.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"../node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n\n//# sourceURL=webpack://swissknife-web/../node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "../src/ai/agent/agent.js":
/*!********************************!*\
  !*** ../src/ai/agent/agent.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* binding */ Agent),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"../node_modules/uuid/dist/esm-browser/v4.js\");\n// src/ai/agent/agent.js\n/**\n * JavaScript implementation of the Agent class\n * Compatible with the TypeScript version for testing\n */\n\n\nclass Agent {\n  /**\n   * Create a new agent instance\n   * @param {Object} options - Agent configuration options\n   * @param {Object} options.model - The language model to use\n   * @param {Array} [options.tools] - Optional tools for the agent to use\n   * @param {number} [options.maxTokens=1000] - Maximum tokens for model responses\n   * @param {number} [options.temperature=0.7] - Temperature for model responses\n   * @param {string} [conversationId] - Conversation ID for tracking exchanges\n   */\n  constructor(options, conversationId) {\n    this.model = options.model;\n    this.agentOptions = { \n      maxTokens: 1000, \n      temperature: 0.7,\n      ...options \n    };\n    \n    this.tools = new Map();\n    this.memory = [];\n    \n    if (options.tools) {\n      for (const tool of options.tools) {\n        this.registerTool(tool);\n      }\n    }\n    \n    this.currentConversationId = conversationId || (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n  }\n\n  /**\n   * Set the current conversation ID\n   * @param {string} conversationId - The conversation ID to set\n   */\n  setCurrentConversationId(conversationId) {\n    if (this.currentConversationId !== conversationId) {\n      this.currentConversationId = conversationId;\n      this.clearMemory(); // Changing conversation usually implies clearing context/memory\n      console.log(`Agent conversation ID set to: ${conversationId}`);\n    }\n  }\n\n  /**\n   * Get the current conversation ID\n   * @returns {string} The current conversation ID\n   */\n  getCurrentConversationId() {\n    return this.currentConversationId;\n  }\n  \n  /**\n   * Register a tool for the agent to use\n   * @param {Object} tool - The tool to register\n   */\n  registerTool(tool) {\n    if (!tool || !tool.name) {\n      throw new Error('Tool must have a name property');\n    }\n    \n    this.tools.set(tool.name, tool);\n    return this;\n  }\n  \n  /**\n   * Clear the agent's memory\n   */\n  clearMemory() {\n    this.memory = [];\n  }\n  \n  /**\n   * Generate content using the agent's model\n   * @param {string} prompt - The prompt to send to the model\n   * @param {Object} [options] - Additional generation options\n   * @returns {Promise<Object>} The generation result\n   */\n  async generate(prompt, options = {}) {\n    // Mock implementation for testing\n    return {\n      content: `Generated content in response to: ${prompt.substring(0, 50)}...`,\n      usage: {\n        promptTokens: Math.floor(prompt.length / 4),\n        completionTokens: 200,\n        totalTokens: Math.floor(prompt.length / 4) + 200\n      },\n      timingMs: 300\n    };\n  }\n  \n  /**\n   * Process a message with the agent\n   * @param {string} message - The message to process\n   * @param {Object} [options] - Processing options\n   * @returns {Promise<Object>} The processing result\n   */\n  async processMessage(message, options = {}) {\n    // Add message to memory\n    this.memory.push({\n      role: 'user',\n      content: message,\n      timestamp: Date.now()\n    });\n    \n    // Generate response\n    const response = await this.generate(message, options);\n    \n    // Add response to memory\n    this.memory.push({\n      role: 'assistant',\n      content: response.content,\n      timestamp: Date.now()\n    });\n    \n    return response;\n  }\n  \n  /**\n   * Perform a reasoning step\n   * @param {Object} context - The context for reasoning\n   * @param {Object} [options] - Reasoning options\n   * @returns {Promise<Object>} The reasoning result\n   */\n  async reason(context, options = {}) {\n    // Mock implementation for testing\n    return {\n      thought: `Reasoning about: ${JSON.stringify(context).substring(0, 50)}...`,\n      nextSteps: ['analyze data', 'form hypothesis', 'test hypothesis'],\n      confidence: 0.85\n    };\n  }\n  \n  /**\n   * Execute a tool\n   * @param {string} toolName - The name of the tool to execute\n   * @param {Object} params - Parameters for the tool\n   * @returns {Promise<Object>} The tool execution result\n   */\n  async useTool(toolName, params = {}) {\n    const tool = this.tools.get(toolName);\n    \n    if (!tool) {\n      throw new Error(`Tool \"${toolName}\" not found`);\n    }\n    \n    try {\n      // Mock execution for testing\n      return {\n        result: `Executed ${toolName} with params: ${JSON.stringify(params).substring(0, 50)}...`,\n        success: true\n      };\n    } catch (error) {\n      return {\n        error: error.message,\n        success: false\n      };\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Agent);\n\n\n//# sourceURL=webpack://swissknife-web/../src/ai/agent/agent.js?");

/***/ }),

/***/ "../src/ai/service.ts":
/*!****************************!*\
  !*** ../src/ai/service.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIService: () => (/* binding */ AIService)\n/* harmony export */ });\n/* harmony import */ var _agent_agent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./agent/agent.js */ \"../src/ai/agent/agent.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../models/registry.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module './models/openai-factory.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../config/manager.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger.js */ \"../src/utils/logger.js\");\n// src/ai/service.ts\n\n\n\n\n\n/**\n * Service for managing AI capabilities\n */\nclass AIService {\n    constructor() {\n        this.initialized = false;\n        this.tools = new Map();\n        this.agents = new Map();\n        // Cache for recent responses to improve performance\n        this.responseCache = new Map();\n        // Cache statistics for performance monitoring\n        this.cacheStats = {\n            hits: 0,\n            misses: 0,\n            evictions: 0,\n            totalRequests: 0\n        };\n        this.modelRegistry = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../models/registry.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).getInstance();\n        this.config = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../config/manager.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).getInstance();\n        this.options = {};\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info('AIService created');\n    }\n    async initialize(options = {}) {\n        this.options = options;\n        await this.lazyInitialize();\n    }\n    /**\n     * Gets the singleton instance of the AIService\n     */\n    static getInstance() {\n        if (!AIService.instance) {\n            AIService.instance = new AIService();\n        }\n        return AIService.instance;\n    }\n    /**\n     * Initializes the AI service\n     * @param options Initialization options\n     */\n    async lazyInitialize() {\n        if (this.initialized)\n            return;\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info('Initializing AIService');\n        // Set up task manager if provided\n        if (this.options.taskManager) {\n            this.taskManager = this.options.taskManager;\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug('TaskManager connected to AIService');\n        }\n        // Register models if requested\n        if (this.options.autoRegisterModels !== false) {\n            await this.registerDefaultModels(this.options.openaiApiKey);\n        }\n        // Register tools if requested\n        if (this.options.autoRegisterTools !== false) {\n            this.registerDefaultTools();\n        }\n        this.initialized = true;\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info('AIService initialized successfully');\n    }\n    async createAgent(id, modelId = 'default', options = {}) {\n        // Ensure we're initialized\n        if (!this.initialized) {\n            throw new Error('AIService must be initialized before creating agents');\n        }\n        // Get the model\n        const model = await this.modelRegistry.getModel(modelId);\n        if (!model) {\n            throw new Error(`Model not found: ${modelId}`);\n        }\n        // Get requested tools\n        const agentTools = [];\n        if (options.tools && options.tools.length > 0) {\n            for (const toolName of options.tools) {\n                const tool = this.tools.get(toolName);\n                if (tool) {\n                    agentTools.push(tool);\n                }\n                else {\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn(`Tool not found: ${toolName}`);\n                }\n            }\n        }\n        // Create the agent\n        const agent = new _agent_agent_js__WEBPACK_IMPORTED_MODULE_0__.Agent({\n            model,\n            tools: agentTools,\n            temperature: options.temperature,\n            maxTokens: options.maxTokens,\n            priority: options.priority,\n            taskManager: this.taskManager\n        });\n        // Store the agent\n        this.agents.set(id, agent);\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`Created agent ${id} with model ${model.id}`);\n        return agent;\n    }\n    /**\n     * Gets a previously created agent\n     * @param id Agent ID\n     */\n    getAgent(id) {\n        return this.agents.get(id);\n    }\n    /**\n     * Registers a tool with the service\n     * @param tool Tool to register\n     */\n    registerTool(tool) {\n        this.tools.set(tool.name, tool);\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`Registered tool: ${tool.name}`);\n    }\n    /**\n     * Gets a registered tool by name\n     * @param name Tool name\n     */\n    getTool(name) {\n        return this.tools.get(name);\n    }\n    /**\n     * Gets all registered tools\n     */\n    getAllTools() {\n        return Array.from(this.tools.values());\n    }\n    /**\n     * Registers default models with the registry\n     * @private\n     */\n    async registerDefaultModels(openaiApiKey) {\n        const modelFactory = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './models/openai-factory.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())();\n        // Register OpenAI models\n        modelFactory.registerStandardModels({\n            apiKey: openaiApiKey || this.config.get('ai.openai.apiKey')\n        });\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info('Registered default AI models');\n    }\n    /**\n     * Registers default tools\n     * @private\n     */\n    registerDefaultTools() {\n        // Register web search tool\n        // Commented out due to incompatible Tool interface \n        // this.registerTool(new WebSearchTool());\n        // Register other default tools here\n        // ...\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info('Registered default AI tools');\n    }\n    /**\n     * Initializes a chat session with the AI agent\n     * @param modelId ID of the model to use\n     * @param systemPrompt Custom system prompt\n     * @param temperature Model temperature\n     */\n    initSession(modelId, systemPrompt, temperature) {\n        this.createAgent('chat-session', modelId, {\n            temperature,\n            tools: [],\n            systemPrompt: systemPrompt\n        });\n        this.activeAgent = this.getAgent('chat-session');\n    }\n    /**\n     * Processes a user message in the current chat session\n     * @param message User input message\n     * @returns Agent response\n     */\n    async processMessage(message) {\n        if (!this.activeAgent) {\n            throw new Error('No active chat session');\n        }\n        // Check if we have a recent cached response for this exact message\n        // Only use cache for simple informational queries to improve performance\n        const cacheKey = this.createCacheKey(message);\n        const cachedResponse = this.responseCache.get(cacheKey);\n        const cacheTTL = 5 * 60 * 1000; // 5 minutes in milliseconds\n        // Track total requests for cache statistics\n        this.cacheStats.totalRequests++;\n        if (cachedResponse && (Date.now() - cachedResponse.timestamp) < cacheTTL) {\n            // Cache hit\n            this.cacheStats.hits++;\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`Using cached response (cache hit rate: ${Math.round((this.cacheStats.hits / this.cacheStats.totalRequests) * 100)}%)`);\n            return {\n                content: cachedResponse.response,\n                cached: true\n            };\n        }\n        // Cache miss\n        this.cacheStats.misses++;\n        try {\n            // Ensure we're initialized before processing\n            await this.lazyInitialize();\n            // No cache hit, proceed with normal processing\n            const response = await this.activeAgent.processMessage(message);\n            // Cache the response if it's cacheable (simple informational queries)\n            if (this.isCacheable(message)) {\n                this.responseCache.set(cacheKey, {\n                    response: response.content,\n                    timestamp: Date.now()\n                });\n                // Limit cache size to prevent memory leaks\n                if (this.responseCache.size > 100) {\n                    // Use a more sophisticated cache eviction strategy - remove oldest entries\n                    const cacheEntries = [...this.responseCache.entries()];\n                    // Sort by timestamp (oldest first)\n                    cacheEntries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n                    // Remove the oldest 10% of entries\n                    const entriesToRemove = Math.max(1, Math.floor(cacheEntries.length * 0.1));\n                    for (let i = 0; i < entriesToRemove; i++) {\n                        this.responseCache.delete(cacheEntries[i][0]);\n                    }\n                    // Update eviction statistics\n                    this.cacheStats.evictions += entriesToRemove;\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`Cache pruned, removed ${entriesToRemove} oldest entries (total evictions: ${this.cacheStats.evictions})`);\n                }\n            }\n            // Return both content and usage metrics if available\n            return {\n                content: response.content,\n                usage: response.usage || undefined,\n                cached: false\n            };\n        }\n        catch (error) {\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.error('Error processing message:', error);\n            // Provide a more user-friendly error message\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            let userFriendlyError = 'An error occurred while processing your message.';\n            let retryAfter = undefined;\n            // Detect common error types and provide better messages with recovery advice\n            if (errorMessage.toLowerCase().includes('token') || errorMessage.toLowerCase().includes('context length')) {\n                userFriendlyError = 'The model encountered a token limit error. To fix this:\\n\\n' +\n                    '1. Try sending a shorter message\\n' +\n                    '2. Clear the conversation history with /clear\\n' +\n                    '3. Consider switching to a model with larger context using /model';\n            }\n            else if (errorMessage.toLowerCase().includes('timeout') || errorMessage.toLowerCase().includes('timed out')) {\n                userFriendlyError = 'The request timed out. This could be due to:\\n\\n' +\n                    '1. High server load\\n' +\n                    '2. Network connectivity issues\\n\\n' +\n                    'Try again in a few moments or use a shorter message.';\n            }\n            else if (errorMessage.toLowerCase().includes('rate limit') || errorMessage.toLowerCase().includes('rate-limit') ||\n                errorMessage.toLowerCase().includes('too many requests')) {\n                // Extract retry-after value if available\n                const retryMatch = errorMessage.match(/retry after (\\d+)/i);\n                if (retryMatch && retryMatch[1]) {\n                    retryAfter = parseInt(retryMatch[1], 10);\n                }\n                userFriendlyError = `Rate limit exceeded. ${retryAfter ? `Please wait ${retryAfter} seconds` : 'Please wait a moment'} before trying again.\\n\\n` +\n                    'This happens when too many requests are sent in a short period.';\n            }\n            else if (errorMessage.toLowerCase().includes('api key') || errorMessage.toLowerCase().includes('authentication')) {\n                userFriendlyError = 'There was an authentication error with the AI provider.\\n\\n' +\n                    'This is likely an API configuration issue. Please check your API keys.';\n            }\n            else if (errorMessage.toLowerCase().includes('network') || errorMessage.toLowerCase().includes('connect') ||\n                errorMessage.toLowerCase().includes('unreachable')) {\n                userFriendlyError = 'A network error occurred while connecting to the AI provider.\\n\\n' +\n                    '1. Check your internet connection\\n' +\n                    '2. Verify that the AI service is operational\\n' +\n                    '3. Try again in a few moments';\n            }\n            else if (errorMessage.toLowerCase().includes('content policy') || errorMessage.toLowerCase().includes('content filter') ||\n                errorMessage.toLowerCase().includes('moderation')) {\n                userFriendlyError = 'Your message was flagged by content safety filters.\\n\\n' +\n                    'The AI provider has policies against certain types of content. ' +\n                    'Please revise your query to comply with content guidelines.';\n            }\n            else if (errorMessage.toLowerCase().includes('server error') || errorMessage.toLowerCase().includes('500') ||\n                errorMessage.toLowerCase().includes('internal')) {\n                userFriendlyError = 'The AI provider is experiencing internal server issues.\\n\\n' +\n                    'This is likely a temporary problem. Please try again in a few minutes.';\n            }\n            return {\n                content: userFriendlyError,\n                error: errorMessage,\n                cached: false,\n                retryAfter\n            };\n        }\n    }\n    /**\n     * Creates a cache key for a message\n     * @param message The message to create a key for\n     * @returns The cache key\n     * @private\n     */\n    createCacheKey(message) {\n        // Simple implementation, could be improved with normalization or hashing\n        return message.trim().toLowerCase();\n    }\n    /**\n     * Determines if a message is cacheable\n     * @param message The message to check\n     * @returns Whether the message is cacheable\n     * @private\n     */\n    isCacheable(message) {\n        // Simple implementation - only cache relatively short informational queries\n        // Could be improved with more sophisticated heuristics\n        const msg = message.trim().toLowerCase();\n        const isCommand = msg.startsWith('/');\n        const isTooLong = msg.length > 200;\n        // Don't cache command inputs or long messages\n        return !isCommand && !isTooLong;\n    }\n    /**\n     * Sets the model for the current chat session\n     * @param modelId ID of the model to use\n     */\n    async setModel(modelId) {\n        if (!this.activeAgent) {\n            throw new Error('No active chat session');\n        }\n        const model = await this.modelRegistry.getModel(modelId);\n        if (!model) {\n            throw new Error(`Model not found: ${modelId}`);\n        }\n        this.activeAgent.setModel(model);\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info(`Chat model switched to: ${modelId}`);\n    }\n    /**\n     * Sets the temperature for the current chat session\n     * @param temperature New temperature value (0-2)\n     */\n    setTemperature(temperature) {\n        if (!this.activeAgent) {\n            throw new Error('No active chat session');\n        }\n        if (temperature < 0 || temperature > 2) {\n            throw new Error('Temperature must be between 0 and 2');\n        }\n        this.activeAgent.setTemperature(temperature);\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info(`Chat temperature set to: ${temperature}`);\n    }\n    /**\n     * Gets cache statistics for performance monitoring\n     * @returns Cache statistics including hits, misses, and hit rate\n     */\n    getCacheStats() {\n        return {\n            ...this.cacheStats,\n            hitRate: this.cacheStats.totalRequests > 0\n                ? this.cacheStats.hits / this.cacheStats.totalRequests\n                : 0,\n            cacheSize: this.responseCache.size\n        };\n    }\n    /**\n     * Clears the response cache\n     */\n    clearCache() {\n        const previousSize = this.responseCache.size;\n        this.responseCache.clear();\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.info(`Response cache cleared (${previousSize} entries removed)`);\n    }\n}\n\n\n//# sourceURL=webpack://swissknife-web/../src/ai/service.ts?");

/***/ }),

/***/ "../src/utils/logger.js":
/*!******************************!*\
  !*** ../src/utils/logger.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevels: () => (/* binding */ LogLevels),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   getLogLevel: () => (/* binding */ getLogLevel),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * Logging utilities for the SwissKnife application\n * \n * This module provides consistent logging functionality across the application.\n */\n\n// Log levels in order of verbosity\nconst LogLevels = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3\n};\n\n// Current log level (can be overridden via config)\nlet currentLogLevel = LogLevels.INFO;\n\n/**\n * Set the current log level\n * \n * @param {number} level The log level to set\n */\nfunction setLogLevel(level) {\n  if (level >= LogLevels.ERROR && level <= LogLevels.DEBUG) {\n    currentLogLevel = level;\n  }\n}\n\n/**\n * Get the current log level\n * \n * @returns {number} The current log level\n */\nfunction getLogLevel() {\n  return currentLogLevel;\n}\n\n/**\n * Format a log message with timestamp and level\n * \n * @param {string} level The log level\n * @param {string} message The message to log\n * @returns {string} The formatted log message\n */\nfunction formatLogMessage(level, message) {\n  const timestamp = new Date().toISOString();\n  return `${timestamp} [${level}] ${message}`;\n}\n\n/**\n * Log an error message\n * \n * @param {string} message The message to log\n * @param {Error} [error] Optional error object\n */\nfunction error(message, error) {\n  if (currentLogLevel >= LogLevels.ERROR) {\n    const formattedMessage = formatLogMessage('ERROR', message);\n    console.error(formattedMessage);\n    if (error) {\n      console.error(error);\n    }\n  }\n}\n\n/**\n * Log a warning message\n * \n * @param {string} message The message to log\n */\nfunction warn(message) {\n  if (currentLogLevel >= LogLevels.WARN) {\n    const formattedMessage = formatLogMessage('WARN', message);\n    console.warn(formattedMessage);\n  }\n}\n\n/**\n * Log an info message\n * \n * @param {string} message The message to log\n */\nfunction info(message) {\n  if (currentLogLevel >= LogLevels.INFO) {\n    const formattedMessage = formatLogMessage('INFO', message);\n    console.info(formattedMessage);\n  }\n}\n\n/**\n * Log a debug message\n * \n * @param {string} message The message to log\n */\nfunction debug(message) {\n  if (currentLogLevel >= LogLevels.DEBUG) {\n    const formattedMessage = formatLogMessage('DEBUG', message);\n    console.debug(formattedMessage);\n  }\n}\n\n// Export a logger object for convenience\nconst logger = {\n  error,\n  warn,\n  info,\n  debug,\n  setLevel: setLogLevel,\n  getLevel: getLogLevel\n};\n\n//# sourceURL=webpack://swissknife-web/../src/utils/logger.js?");

/***/ })

}]);