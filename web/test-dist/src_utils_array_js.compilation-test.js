"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkswissknife_web"] = self["webpackChunkswissknife_web"] || []).push([["src_utils_array_js"],{

/***/ "../src/utils/array.js":
/*!*****************************!*\
  !*** ../src/utils/array.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Array utility functions\n */\n\n/**\n * Insert a separator between array elements\n */\nfunction intersperse(array, separator) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (array.length <= 1) {\n    return [...array];\n  }\n  \n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    result.push(array[i]);\n    if (i < array.length - 1) {\n      // Support both function and value separators\n      const separatorValue = typeof separator === 'function' ? separator(i + 1) : separator;\n      result.push(separatorValue);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Chunk an array into smaller arrays of specified size\n */\nfunction chunk(array, size) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof size !== 'number' || size <= 0) {\n    throw new Error('Size must be a positive number');\n  }\n  \n  const result = [];\n  for (let i = 0; i < array.length; i += size) {\n    result.push(array.slice(i, i + size));\n  }\n  \n  return result;\n}\n\n/**\n * Remove duplicate elements from array\n */\nfunction unique(array) {\n  if (!Array.isArray(array)) {\n    throw new Error('Argument must be an array');\n  }\n  \n  return [...new Set(array)];\n}\n\n/**\n * Remove duplicate elements using a key function\n */\nfunction uniqueBy(array, keyFn) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof keyFn !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const seen = new Set();\n  return array.filter(item => {\n    const key = keyFn(item);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.add(key);\n    return true;\n  });\n}\n\n/**\n * Flatten nested arrays\n */\nfunction flatten(array, depth = 1) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  return array.flat(depth);\n}\n\n/**\n * Group array elements by a key function\n */\nfunction groupBy(array, keyFn) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof keyFn !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  return array.reduce((groups, item) => {\n    const key = keyFn(item);\n    if (!groups[key]) {\n      groups[key] = [];\n    }\n    groups[key].push(item);\n    return groups;\n  }, {});\n}\n\n/**\n * Sort array by multiple criteria\n */\nfunction sortBy(array, ...criteria) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  return [...array].sort((a, b) => {\n    for (const criterion of criteria) {\n      let aVal, bVal;\n      \n      if (typeof criterion === 'function') {\n        aVal = criterion(a);\n        bVal = criterion(b);\n      } else if (typeof criterion === 'string') {\n        aVal = a[criterion];\n        bVal = b[criterion];\n      } else {\n        throw new Error('Criteria must be functions or strings');\n      }\n      \n      if (aVal < bVal) return -1;\n      if (aVal > bVal) return 1;\n    }\n    return 0;\n  });\n}\n\n/**\n * Find the intersection of multiple arrays\n */\nfunction intersection(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n  \n  if (!arrays.every(arr => Array.isArray(arr))) {\n    throw new Error('All arguments must be arrays');\n  }\n  \n  const first = arrays[0];\n  const others = arrays.slice(1);\n  \n  return first.filter(item => \n    others.every(arr => arr.includes(item))\n  );\n}\n\n/**\n * Find the difference between arrays\n */\nfunction difference(array, ...others) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (!others.every(arr => Array.isArray(arr))) {\n    throw new Error('All other arguments must be arrays');\n  }\n  \n  const excluded = new Set(others.flat());\n  return array.filter(item => !excluded.has(item));\n}\n\n/**\n * Partition array into two arrays based on predicate\n */\nfunction partition(array, predicate) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof predicate !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const truthy = [];\n  const falsy = [];\n  \n  for (const item of array) {\n    if (predicate(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item);\n    }\n  }\n  \n  return [truthy, falsy];\n}\n\n/**\n * Take elements from the beginning of array\n */\nfunction take(array, n) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof n !== 'number' || n < 0) {\n    throw new Error('Second argument must be a non-negative number');\n  }\n  \n  return array.slice(0, n);\n}\n\n/**\n * Drop elements from the beginning of array\n */\nfunction drop(array, n) {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof n !== 'number' || n < 0) {\n    throw new Error('Second argument must be a non-negative number');\n  }\n  \n  return array.slice(n);\n}\n\n/**\n * Zip multiple arrays together\n */\nfunction zip(...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n  \n  if (!arrays.every(arr => Array.isArray(arr))) {\n    throw new Error('All arguments must be arrays');\n  }\n  \n  const maxLength = Math.max(...arrays.map(arr => arr.length));\n  const result = [];\n  \n  for (let i = 0; i < maxLength; i++) {\n    result.push(arrays.map(arr => arr[i]));\n  }\n  \n  return result;\n}\n\nmodule.exports = {\n  intersperse,\n  chunk,\n  unique,\n  uniqueBy,\n  flatten,\n  groupBy,\n  sortBy,\n  intersection,\n  difference,\n  partition,\n  take,\n  drop,\n  zip\n};\n\n\n//# sourceURL=webpack://swissknife-web/../src/utils/array.js?");

/***/ })

}]);