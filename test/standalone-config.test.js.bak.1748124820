/**
 * Standalone Configuration Manager Test
 * 
 * This test provides a complete standalone configuration system implementation
 * that can be tested without any external dependencies.
 */

// Simple configuration manager
class ConfigManager {
  constructor(initialConfig = {}) {
    this.config = { ...initialConfig };
    this.validators = {};
    this.watchers = {};
    this.defaults = {};
  }
  
  get(key, defaultValue) {
    const parts = key.split('.');
    let current = this.config;
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (current[part] === undefined) {
        return defaultValue !== undefined ? defaultValue : this.defaults[key];
      }
      current = current[part];
    }
    
    return current;
  }
  
  set(key, value) {
    // Check if there's a validator for this key
    if (this.validators[key] && !this.validators[key](value)) {
      throw new Error(`Invalid value for ${key}: ${value}`);
    }
    
    const parts = key.split('.');
    let current = this.config;
    
    // Create nested objects as needed
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (current[part] === undefined) {
        current[part] = {};
      }
      current = current[part];
    }
    
    // Store the value
    const lastPart = parts[parts.length - 1];
    const oldValue = current[lastPart];
    current[lastPart] = value;
    
    // Notify watchers
    if (this.watchers[key]) {
      this.watchers[key].forEach(callback => {
        try {
          callback(value, oldValue, key);
        } catch (error) {
          console.error(`Error in config watcher for ${key}:`, error);
        }
      });
    }
    
    return this;
  }
  
  has(key) {
    const parts = key.split('.');
    let current = this.config;
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (current[part] === undefined) {
        return false;
      }
      current = current[part];
    }
    
    return true;
  }
  
  delete(key) {
    const parts = key.split('.');
    let current = this.config;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (current[part] === undefined) {
        return false;
      }
      current = current[part];
    }
    
    const lastPart = parts[parts.length - 1];
    if (current[lastPart] === undefined) {
      return false;
    }
    
    delete current[lastPart];
    return true;
  }
  
  setValidator(key, validator) {
    if (typeof validator !== 'function') {
      throw new Error('Validator must be a function');
    }
    this.validators[key] = validator;
    return this;
  }
  
  removeValidator(key) {
    delete this.validators[key];
    return this;
  }
  
  watch(key, callback) {
    if (typeof callback !== 'function') {
      throw new Error('Watcher callback must be a function');
    }
    
    if (!this.watchers[key]) {
      this.watchers[key] = [];
    }
    
    this.watchers[key].push(callback);
    return this;
  }
  
  unwatch(key, callback) {
    if (!this.watchers[key]) {
      return this;
    }
    
    if (!callback) {
      delete this.watchers[key];
    } else {
      this.watchers[key] = this.watchers[key].filter(cb => cb !== callback);
      if (this.watchers[key].length === 0) {
        delete this.watchers[key];
      }
    }
    
    return this;
  }
  
  setDefaults(defaults) {
    this.defaults = { ...this.defaults, ...defaults };
    return this;
  }
  
  reset() {
    this.config = {};
    return this;
  }
  
  getAll() {
    return { ...this.config };
  }
}

// Tests
describe('Standalone Configuration Manager', () => {
  let config;
  
  beforeEach(() => {
    config = new ConfigManager({
      app: {
        name: 'TestApp',
        version: '1.0.0'
      },
      server: {
        port: 3000,
        host: 'localhost'
      }
    });
  });
  
  test('config manager can be instantiated', () => {
    expect(config).toBeDefined();
    expect(config).toBeInstanceOf(ConfigManager);
  });
  
  test('get returns correct values', () => {
    expect(config.get('app.name')).toBe('TestApp');
    expect(config.get('app.version')).toBe('1.0.0');
    expect(config.get('server.port')).toBe(3000);
    expect(config.get('server.host')).toBe('localhost');
  });
  
  test('get returns default value for missing keys', () => {
    expect(config.get('missing.key', 'defaultValue')).toBe('defaultValue');
    expect(config.get('app.missing', 42)).toBe(42);
  });
  
  test('set updates values correctly', () => {
    config.set('app.name', 'NewApp');
    config.set('server.port', 8080);
    
    expect(config.get('app.name')).toBe('NewApp');
    expect(config.get('server.port')).toBe(8080);
  });
  
  test('set creates nested objects as needed', () => {
    config.set('database.url', 'mongodb://localhost');
    config.set('database.options.useNewUrlParser', true);
    
    expect(config.get('database.url')).toBe('mongodb://localhost');
    expect(config.get('database.options.useNewUrlParser')).toBe(true);
  });
  
  test('has checks if key exists', () => {
    expect(config.has('app.name')).toBe(true);
    expect(config.has('missing.key')).toBe(false);
    expect(config.has('app.missing')).toBe(false);
  });
  
  test('delete removes keys', () => {
    expect(config.delete('app.name')).toBe(true);
    expect(config.has('app.name')).toBe(false);
    expect(config.delete('missing.key')).toBe(false);
  });
  
  test('validators prevent invalid values', () => {
    config.setValidator('server.port', value => {
      return Number.isInteger(value) && value > 0 && value < 65536;
    });
    
    config.set('server.port', 8080); // Valid
    expect(config.get('server.port')).toBe(8080);
    
    expect(() => config.set('server.port', -1)).toThrow('Invalid value');
    expect(() => config.set('server.port', 'string')).toThrow('Invalid value');
    expect(config.get('server.port')).toBe(8080); // Unchanged
  });
  
  test('watchers are notified on changes', () => {
    const watcher = jest.fn();
    config.watch('server.port', watcher);
    
    config.set('server.port', 8080);
    expect(watcher).toHaveBeenCalledWith(8080, 3000, 'server.port');
    
    config.set('server.host', 'new-host'); // Different key
    expect(watcher).toHaveBeenCalledTimes(1); // Not called again
  });
  
  test('unwatch removes watchers', () => {
    const watcher = jest.fn();
    config.watch('server.port', watcher);
    
    config.unwatch('server.port', watcher);
    config.set('server.port', 8080);
    expect(watcher).not.toHaveBeenCalled();
  });
  
  test('defaults are used when key is missing', () => {
    config.setDefaults({
      'missing.key': 'defaultValue',
      'app.missing': 42
    });
    
    expect(config.get('missing.key')).toBe('defaultValue');
    expect(config.get('app.missing')).toBe(42);
  });
  
  test('reset clears all configuration', () => {
    config.reset();
    expect(config.has('app.name')).toBe(false);
    expect(config.has('server.port')).toBe(false);
    expect(config.getAll()).toEqual({});
  });
  
  test('getAll returns copy of config', () => {
    const all = config.getAll();
    // Make a deep modification to verify it doesn't affect the original
    if (all.app) {
      all.app.name = 'Changed';
      expect(config.get('app.name')).toBe('TestApp'); // Not affected by change to copy
    } else {
      // If app is not defined, add a new property instead
      all.newProperty = 'test';
      expect(config.has('newProperty')).toBe(false); // Original should not have this
    }
  });
});
