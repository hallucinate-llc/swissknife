/**
 * Unit tests for PerformanceMonitor
 */


describe('PerformanceMonitor', () => {
  let performanceMonitor: any;
  
  beforeEach(() => {
    // Reset singleton
    (PerformanceMonitor as any).instance = null;
    
    // Create new instance
    performanceMonitor = PerformanceMonitor.getInstance();
    
    // Mock Date.now and performance.now
    jest.spyOn(Date, 'now').mockImplementation(() => 1000);
    jest.spyOn(performance, 'now').mockImplementation(() => 2000);
  });
  
  afterEach(() => {
    jest.restoreAllMocks();
  });
  
  describe('basic timing', () => {
    it('should measure operation time correctly', async () => {
      // Mock performance.now to simulate elapsed time
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2500);
      
      // Act
      const result = await performanceMonitor.measure('test-operation', async () => {
        return 'test-result';
      });
      
      // Assert
      expect(result).toBe('test-result');
      
      // Get timing data
      const timingData = performanceMonitor.getOperationTiming('test-operation');
      expect(timingData).toBeDefined();
      expect(timingData.duration).toBe(500); // 2500 - 2000
      expect(timingData.count).toBe(1);
    });
    
    it('should measure operation time with manual start/end', () => {
      // Skip if not supported
      if (typeof performanceMonitor.startMeasurement !== 'function' ||
          typeof performanceMonitor.endMeasurement !== 'function') {
        console.log('Skipping manual timing test - methods not implemented');
        return;
      }
      
      // Mock performance.now to simulate elapsed time
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2800);
      
      // Act
      const id = performanceMonitor.startMeasurement('manual-operation');
      const endResult = performanceMonitor.endMeasurement(id);
      
      // Assert
      expect(id).toBeDefined();
      expect(endResult.duration).toBe(800); // 2800 - 2000
      
      // Verify stored data
      const timingData = performanceMonitor.getOperationTiming('manual-operation');
      expect(timingData).toBeDefined();
      expect(timingData.duration).toBe(800);
      expect(timingData.count).toBe(1);
    });
    
    it('should accumulate multiple operation timings', async () => {
      // Mock performance.now to simulate elapsed time for multiple calls
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock
        .mockReturnValueOnce(2000).mockReturnValueOnce(2200) // First call: 200ms
        .mockReturnValueOnce(2300).mockReturnValueOnce(2600) // Second call: 300ms
        .mockReturnValueOnce(2700).mockReturnValueOnce(3000); // Third call: 300ms
      
      // Act - Measure same operation multiple times
      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-1';
      });
      
      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-2';
      });
      
      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-3';
      });
      
      // Assert
      const timingData = performanceMonitor.getOperationTiming('repeated-operation');
      expect(timingData).toBeDefined();
      expect(timingData.count).toBe(3);
      expect(timingData.totalDuration).toBe(800); // 200 + 300 + 300
      expect(timingData.averageDuration).toBe(800 / 3);
      expect(timingData.minDuration).toBe(200);
      expect(timingData.maxDuration).toBe(300);
    });
    
    it('should handle errors during measurement', async () => {
      // Mock performance.now
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2400);
      
      // Define a function that throws
      const errorFunction = async () => {
        throw new Error('Test error');
      };
      
      // Act & Assert
      await expect(performanceMonitor.measure('error-operation', errorFunction))
        .rejects.toThrow('Test error');
      
      // Should still record timing even though operation failed
      const timingData = performanceMonitor.getOperationTiming('error-operation');
      expect(timingData).toBeDefined();
      expect(timingData.duration).toBe(400); // 2400 - 2000
      expect(timingData.count).toBe(1);
      expect(timingData.errorCount).toBe(1);
    });
  });

  describe('basic timing', () => {
    it('should measure operation time correctly', async () => {
      // Mock performance.now to simulate elapsed time
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2500);

      // Act
      const result = await performanceMonitor.measure('test-operation', async () => {
        return 'test-result';
      });

      // Assert
      expect(result).toBe('test-result');

      // Get timing data
      const timingData = performanceMonitor.getOperationTiming('test-operation');
      expect(timingData).toBeDefined();
      expect(timingData?.duration).toBe(500); // 2500 - 2000
      expect(timingData?.count).toBe(1);
    });

    it('should accumulate multiple operation timings', async () => {
      // Mock performance.now to simulate elapsed time for multiple calls
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock
        .mockReturnValueOnce(2000).mockReturnValueOnce(2200) // First call: 200ms
        .mockReturnValueOnce(2300).mockReturnValueOnce(2600) // Second call: 300ms
        .mockReturnValueOnce(2700).mockReturnValueOnce(3000); // Third call: 300ms

      // Act - Measure same operation multiple times
      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-1';
      });

      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-2';
      });

      await performanceMonitor.measure('repeated-operation', async () => {
        return 'result-3';
      });

      // Assert
      const timingData = performanceMonitor.getOperationTiming('repeated-operation');
      expect(timingData).toBeDefined();
      expect(timingData?.count).toBe(3);
      expect(timingData?.totalDuration).toBe(800); // 200 + 300 + 300
    });

    it('should handle errors during measurement', async () => {
      // Mock performance.now
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2400);

      // Define a function that throws
      const errorFunction = async () => {
        throw new Error('Test error');
      };

      // Act & Assert
      await expect(performanceMonitor.measure('error-operation', errorFunction))
        .rejects.toThrow('Test error');

      // Should still record timing even though operation failed
      const timingData = performanceMonitor.getOperationTiming('error-operation');
      expect(timingData).toBeDefined();
      expect(timingData?.duration).toBe(400); // 2400 - 2000
      expect(timingData?.count).toBe(1);
      expect(timingData?.errorCount).toBe(1);
    });
  });

  describe('reporting', () => {
    it('should provide summary of all operations', () => {
      // Arrange - Measure a few operations
      // Mock performance.now for deterministic results
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock
        .mockReturnValueOnce(2000).mockReturnValueOnce(2200) // op1: 200ms
        .mockReturnValueOnce(2300).mockReturnValueOnce(2500) // op2: 200ms
        .mockReturnValueOnce(2600).mockReturnValueOnce(3100); // op3: 500ms

      performanceMonitor.measure('operation-1', async () => 'result-1');
      performanceMonitor.measure('operation-2', async () => 'result-2');
      performanceMonitor.measure('operation-3', async () => 'result-3');

      // Act
      const summary = performanceMonitor.getSummary();

      // Assert
      expect(summary).toBeDefined();
      expect(summary.length).toBe(3);

      // Should include all operations
      expect(summary.find((op: any) => op.name === 'operation-1')).toBeDefined();
      expect(summary.find((op: any) => op.name === 'operation-2')).toBeDefined();
      expect(summary.find((op: any) => op.name === 'operation-3')).toBeDefined();

      // Should have correct timings
      expect(summary.find((op: any) => op.name === 'operation-1').duration).to.equal(200);
      expect(summary.find((op: any) => op.name === 'operation-2').duration).to.equal(200);
      expect(summary.find((op: any) => op.name === 'operation-3').duration).to.equal(500);
    });

    it('should reset timings', () => {
      // Arrange - Create some timings
      // Mock performance.now
      const perfNowMock = jest.spyOn(performance, 'now');
      perfNowMock.mockReturnValueOnce(2000).mockReturnValueOnce(2500);

      performanceMonitor.measure('operation-to-reset', async () => 'result');

      // Verify initial state
      expect(performanceMonitor.getOperationTiming('operation-to-reset')).toBeDefined();

      // Act
      performanceMonitor.reset();

      // Assert
      expect(performanceMonitor.getOperationTiming('operation-to-reset')).to.be.undefined;
    });
  });
});
