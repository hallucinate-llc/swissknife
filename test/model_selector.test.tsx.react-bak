/**
 * Unit Tests for the ModelSelector React/Ink Component.
 * Testing React hooks and component functionality.
 */
import React from 'react';

// --- Mock Setup ---

// Mock React hooks
jest.mock('react', () => {
  const originalReact = jest.requireActual('react');
  const mockSetState = jest.fn();
  return {
    ...originalReact,
    useState: jest.fn((initialValue) => [initialValue, mockSetState]),
    useEffect: jest.fn((fn) => fn()),
    useCallback: jest.fn((fn) => fn),
    useRef: jest.fn((initialValue) => ({ current: initialValue })),
  };
});

// Mock config utilities
jest.mock('../src/utils/config.js', () => require('./mocks/utils/config.js'));

// Mock session state utilities
jest.mock('../src/utils/sessionState.js', () => require('./mocks/utils/sessionState.js'));

// Mock Ink components
const mockRender = jest.fn();
jest.mock('ink', () => require('./mocks/stubs/ink-mock.js'));

// Mock hooks
jest.mock('../src/hooks/useExitOnCtrlCD.js', () => ({
  useExitOnCtrlCD: jest.fn(() => ({ pending: false, keyName: null })),
}));

// Mock custom components
jest.mock('../src/components/CustomSelect/select.js', () => ({
  Select: jest.fn(({ items, onSelect }) => {
    mockRender('Select');
    return null;
  }),
}));

jest.mock('../src/components/TextInput.js', () => {
  const TextInput = jest.fn(() => {
    mockRender('TextInput');
    return null;
  });
  return TextInput;
});

// Import mocked functions to control their behavior

// Type the mocked functions
const mockedGetGlobalConfig = getGlobalConfig as jest.MockedFunction<typeof getGlobalConfig>;
const mockedSaveGlobalConfig = saveGlobalConfig as jest.MockedFunction<typeof saveGlobalConfig>;
const mockedGetSessionState = getSessionState as jest.MockedFunction<typeof getSessionState>;
const mockedSetSessionState = setSessionState as jest.MockedFunction<typeof setSessionState>;

// Import the component to test

// --- Test Data and State ---

// Default mock config state for resetting
const initialMockConfig = () => ({
  primaryProvider: 'lilypad',
  largeModelName: 'llama3.1:8b',
  smallModelName: 'llama3.1:8b',
  largeModelApiKeys: ['test-api-key-1'],
  smallModelApiKeys: ['test-api-key-3'],
});

// Define SessionState type based on usage
type SessionState = {
  modelErrors: Record<string, any>;
  currentError: Error | null;
  currentApiKeyIndex: { small: number; large: number };
  failedApiKeys: { small: string[]; large: string[] };
};

// Default mock session state for resetting
const initialMockSessionState = (): SessionState => ({
  modelErrors: {},
  currentError: null,
  currentApiKeyIndex: { small: 0, large: 0 },
  failedApiKeys: { small: [], large: [] },
});

let mockConfig: any;
let mockSessionStateData: any;

// --- Test Suite ---

describe('ModelSelector Component', () => {
  let onDoneMock: jest.Mock;
  
  // Setup before each test
  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    // Reset state objects
    mockConfig = initialMockConfig();
    mockSessionStateData = initialMockSessionState();

    // Set up default mock returns for config/session utilities
    mockedGetGlobalConfig.mockReturnValue(mockConfig);
    mockedSaveGlobalConfig.mockImplementation((newConfig: any) => {
      Object.assign(mockConfig, newConfig);
      return true;
    });
    mockedGetSessionState.mockImplementation((key?: any) => {
      if (key) {
        return mockSessionStateData[key];
      }
      return mockSessionStateData;
    });
    mockedSetSessionState.mockImplementation((keyOrState: any, value?: any) => {
      if (typeof keyOrState === 'string') {
         if (keyOrState in mockSessionStateData) {
            mockSessionStateData[keyOrState] = value;
         } else {
            console.warn(`Attempted to set invalid session state key: ${keyOrState}`);
         }
      } else {
        Object.assign(mockSessionStateData, keyOrState);
      }
    });

    // Create a mock for the onDone callback
    onDoneMock = jest.fn();
  });

  // Basic tests for functional component
  it('should initialize with the correct state', () => {
    // Render the component with mocked props
    ModelSelector({ onDone: onDoneMock });
    
    // Verify getGlobalConfig was called to initialize state
    expect(mockedGetGlobalConfig).toHaveBeenCalled();
    
    // Verify initial screen stack (check that useState was called with expected args)
    expect(React.useState).toHaveBeenCalledWith(['modelType']);
  });

  it('should handle config loading', () => {
    const testConfig = {
      primaryProvider: 'openai',
      largeModelName: 'gpt-4',
      smallModelName: 'gpt-3.5-turbo',
      largeModelApiKeys: ['key1'],
      smallModelApiKeys: ['key2'],
    };
    
    mockedGetGlobalConfig.mockReturnValue(testConfig);
    
    ModelSelector({ onDone: onDoneMock });
    
    expect(mockedGetGlobalConfig).toHaveBeenCalled();
  });

  it('should handle session state management', () => {
    ModelSelector({ onDone: onDoneMock });
    
    expect(mockedGetSessionState).toHaveBeenCalled();
  });
});
